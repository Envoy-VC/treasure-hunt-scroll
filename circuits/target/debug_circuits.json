{"debug_symbols":[{"locations":{"32":[{"span":{"start":137,"end":171},"file":1},{"span":{"start":755,"end":793},"file":24}],"33":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"34":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"35":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"36":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"37":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"38":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"39":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"40":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"41":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"42":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"43":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"44":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"45":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"46":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"47":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":287,"end":313},"file":0}],"48":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"49":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"50":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"51":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"52":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"53":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"54":[{"span":{"start":190,"end":233},"file":1},{"span":{"start":347,"end":357},"file":0}],"55":[{"span":{"start":247,"end":273},"file":1}],"56":[{"span":{"start":247,"end":273},"file":1}],"57":[{"span":{"start":247,"end":273},"file":1}],"58":[{"span":{"start":356,"end":403},"file":1},{"span":{"start":723,"end":752},"file":0},{"span":{"start":755,"end":793},"file":24}],"59":[{"span":{"start":356,"end":403},"file":1},{"span":{"start":824,"end":868},"file":0},{"span":{"start":755,"end":793},"file":24}],"60":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"61":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"62":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"63":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"64":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"65":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"66":[{"span":{"start":326,"end":404},"file":1},{"span":{"start":490,"end":521},"file":0}],"67":[{"span":{"start":417,"end":431},"file":1}]}}],"file_map":{"0":{"source":"use dep::std;\n\nstruct Riddle {\n    question: Field,\n    answerHash: Field,\n    position: Field,\n}\n\npub fn getRiddleForPos(pos: Field, riddles: [Riddle; 3]) -> Riddle {\n    let mut riddle = Riddle { question: 0, answerHash: 0, position: 0 };\n\n    for i in 0..3 {\n        if {\n            riddles[i].position == pos\n        } {\n            riddle = riddles[i];\n        }\n    }\n\n    riddle\n}\n\npub fn solveRiddle(riddle: Riddle, answerHash: Field) -> bool {\n    let mut solved = false;\n\n    if riddle.answerHash == answerHash {\n        solved = true;\n    }\n    solved\n}\n\npub fn getSolutionHash<M>(solution: [u8; 32], position: [Field; 2]) -> Field {\n    let mut sol: [Field; 32] = u8ArrToFieldArr(solution);\n\n    let solHash = std::hash::pedersen_hash(sol);\n    let posHash = std::hash::pedersen_hash(position);\n\n    let hash = std::hash::pedersen_hash([solHash, posHash]);\n    hash\n}\n\npub fn u8ArrToFieldArr<N>(data: [u8; N]) -> [Field; N] {\n    let mut fieldData: [Field; N] = [0; N];\n    for i in 0..N {\n        fieldData[i] = data[i] as Field;\n    }\n    fieldData\n}\n\npub fn constructRiddle<N, M>(question: [u8; N], position: [Field; 2], answerHash: [u8; 32]) -> Riddle {\n    let questionHash = std::hash::pedersen_hash(u8ArrToFieldArr(question));\n    let answerHash = getSolutionHash(answerHash, position);\n    let positionHash = std::hash::pedersen_hash(position);\n\n    let riddle = Riddle { question: questionHash, answerHash, position: positionHash };\n    riddle\n}\n","path":"/Users/envoy1084/Projects/Personal/treasure-hunt-scroll/circuits/src/treasure.nr"},"1":{"source":"mod treasure;\nuse dep::std;\n\nfn main(riddles: pub [treasure::Riddle; 3], position: [Field; 2], answerHash: [u8; 32]) {\n    let posHash = std::hash::pedersen_hash(position);\n    let riddle = treasure::getRiddleForPos(posHash, riddles);\n\n    assert(riddle.position == posHash, \"No Riddle found for position\");\n\n    let result = treasure::solveRiddle(riddle, treasure::getSolutionHash(answerHash, position));\n    assert(result == true, \"Riddle not solved\");\n}\n\n#[test]\nfn test_correct() {\n    let riddles  = getRiddles();\n    let position = [32, 28];\n    let answer = std::hash::keccak256(\"Casper\".as_bytes(), \"Casper\".as_bytes().len() as u32);\n    main(riddles, position, answer);\n}\n\nfn getRiddles() -> [treasure::Riddle; 3] {\n    let mut riddle = treasure::Riddle { question: 0, answerHash: 0, position: 0 };\n    let mut riddles: [treasure::Riddle; 3] = [riddle; 3];\n\n    riddles[0] = treasure::constructRiddle(\n        \"I am the block number on the Ethereum blockchain where The DAO incident took place. I caused a significant community discussion and a subsequent fork. Which block number am I?\".as_bytes(),\n        [26, 32],\n        std::hash::keccak256(\"1920000\".as_bytes(), \"1920000\".as_bytes().len() as u32)\n    );\n\n    riddles[1] = treasure::constructRiddle(\n        \"I am a consensus algorithm introduced to Ethereum to replace proof-of-work. I involve validators who lock up a certain amount of cryptocurrency to validate blocks. What is my name?\".as_bytes(),\n        [32, 28],\n        std::hash::keccak256(\"Casper\".as_bytes(), \"Casper\".as_bytes().len() as u32)\n    );\n\n    riddles[2] = treasure::constructRiddle(\n        \"In 2014, I became the first cryptocurrency to implement the X11 hashing algorithm, aiming for increased security and energy efficiency. What is my name?\".as_bytes(),\n        [4, 2],\n        std::hash::keccak256(\"Dash\".as_bytes(), \"Dash\".as_bytes().len() as u32)\n    );\n\n    riddles\n}\n","path":"/Users/envoy1084/Projects/Personal/treasure-hunt-scroll/circuits/src/main.nr"},"24":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n","path":"std/hash.nr"}},"warnings":[]}